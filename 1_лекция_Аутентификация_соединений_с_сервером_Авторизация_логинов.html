<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1><b>Аутентификация соединений с сервером Авторизация логинов для подключения к базам данных</b></h1>
    <h2><b>Аутентификация vs. Авторизация: Краткое различие</b></h2>
    <ul>
        <li>•	<b>Аутентификация (Authentication - AuthN)</b>: Процесс <strong>проверки подлинности</strong> пользователя. Ответ на вопрос <strong>"Кто вы?"</strong>. Это проверка логина/пароля, отпечатка пальца, Face ID и т.д.</li>
        <li>•	<b>Авторизация (Authorization - AuthZ):</b> Процесс <strong>проверки прав</strong> пользователя на выполнение определенных действий. Ответ на вопрос <strong>"Что вам разрешено делать?"</strong>. Это проверка ролей (админ, модератор, пользователь) и разрешений (может ли он читать, писать, удалять).</li>
	</ul>
    <h3>Простая аналогия:</h3>
    <ol>
        <li>1.	Вы предъявляете паспорт на ресепшене отеля -> <strong>Аутентификация</strong> (доказали, что вы это вы).</li>
        <li>2.	Вам выдают ключ от номера 505, но не от номера 506 -> <strong>Авторизация</strong> (определили, к чему у вас есть доступ).</li>
    </ol>
<p>________________________________________</p>
    <h2>Часть 1: Аутентификация соединений с сервером</h2>
    <p>Здесь речь идет о том, как ваше веб-приложение (клиент) доказывает свою подлинность серверу, на котором работает backend. Это особенно важно для API.</p>
    <h3>Распространенные методы аутентификации сервер-сервер или клиент-сервер:</h3>
    <ol>
    <li>1.	API Keys (Ключи API)</li>
	<ul>
    <li>o	Как работает: Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса).</li>
    <li>o	Плюсы: Простота реализации и использование.</li>
    <li>o	Минусы: Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. Никогда не используйте для аутентификации пользователей! Подходит для аутентификации сервисов между собой в доверенной среде.</li>
    </ul>
    <li>2.	JWT (JSON Web Tokens)</li>
    <ul>
	<li>o	Как работает:</li>
    <ol>
    <li>1.	Пользователь логинится (отправляет логин/пароль).</li>
    <li>2.	Сервер проверяет данные, создает JWT-токен (подписанный цифровой подписью) и отдает его клиенту.</li>
    <li>3.	Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer <токен> при каждом последующем запросе.</li>
    <li>4.	Сервер проверяет подпись токена и извлекает из него данные (например, user id). Ему не нужно хранить сессию на сервере (stateless).</li>
    </ol>
    <li>o	Плюсы: Масштабируемость (не требует хранения сессий на сервере), удобство для мобильных и SPA-приложений.</li>
    <li>o	Минусы: Сложность с немедленной инвалидацией токена (пока не истечет его срок жизни).</li>
    </ul>
    <li>3.	OAuth 2.0 / OpenID Connect</li>
    <ul>
    <li>o	Как работает: Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа.</li>
    <li>o	Плюсы: Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами.</li>
    <li>o	Минусы: Более сложная реализация на стороне backend.</li>
    </ul>
    <li>4.	Аутентификация на основе сессий (Cookies)</li>
    <ul>
    <li>o	Как работает:</li>
    <ol>
    <li>1.	Пользователь логинится.</li>
    <li>2.	Сервер создает запись сессии в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии (Session ID) в cookie (с флагами HttpOnly, Secure).</li>
    <li>3.	Браузер автоматически отправляет этот cookie с каждым запросом.</li>
    <li>4.	Сервер проверяет ID сессии в своем хранилище.</li>
    </ol>
    <li>o	Плюсы: Простота инвалидации сессии (удалил запись — доступ закрыт). Безопаснее хранения JWT в LocalStorage.</li>
    <li>o	Минусы: Требует stateful-сервера и хранения сессий, что может усложнить масштабирование.</li>
    </ul>
<p>________________________________________</p>
    <h2>Часть 2: Авторизация логинов для подключения к базам данных</h2>
Здесь речь идет о том, как ваше backend-приложение подключается к СУБД (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация.
Ключевые принципы:
1.	Принцип наименьших привилегий (Principle of Least Privilege)
o	Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь ровно те права, которые ей необходимы, и не более.
o	Пример: Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP.
2.	Использование разных учетных записей для разных целей
o	Не используйте одну супер-учетку (root/admin) для всего.
o	Создайте отдельного пользователя БД специально для вашего приложения.
o	Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами.
3.	Безопасное хранение учетных данных
o	Никогда не храните логины/пароли от БД в коде приложения (в гите)!
o	Используйте переменные окружения (Environment Variables) или секреты (Secrets):
	Локально: файл .env (который добавлен в .gitignore).
	На продакшене: используйте механизмы вашего хостинга/платформы (Environment Variables в Heroku, Secrets в Kubernetes, AWS Secrets Manager, HashiCorp Vault).
o	Пример для Node.js и .env:
bash
# Файл .env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mydatabase
DB_USER=myapp_user
DB_PASSWORD=very_strong_password_123
javascript
// Код приложения
const { Pool } = require('pg');
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});
4.	Использование SSL/TLS для подключения к БД
o	Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).
o	Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата.
Практическое задание для студентов:
1.	Создайте безопасного пользователя БД:
o	Подключитесь к вашей СУБД (например, PostgreSQL) из-под пользователя postgres.
o	Создайте новую базу данных: CREATE DATABASE myapp;
o	Создайте пользователя: CREATE USER myapp_user WITH PASSWORD 'secure_password';
o	Дайте ему только необходимые права только на эту БД: GRANT CONNECT, SELECT, INSERT, UPDATE ON DATABASE myapp TO myapp_user; (список прав нужно уточнить под вашу задачу).
o	Настройте ваше приложение на подключение с этими credentials.
2.	Настройте переменные окружения:
o	Создайте файл .env в корне вашего проекта.
o	Добавьте в него строки с данными для подключения к БД (как в примере выше).
o	Убедитесь, что файл .env добавлен в .gitignore.
o	Настройте ваше приложение (на любом языке) читать эти переменные.
Итог: Всегда разделяйте аутентификацию пользователей вашего приложения и аутентификацию самого приложения для доступа к БД. Для обоих случаев применяйте принцип наименьших привилегий и никогда не храните секреты в коде.
</body>
</html>

